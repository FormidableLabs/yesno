# YesNo

YesNo is an HTTP testing library for NodeJS that uses [Mitm](https://github.com/moll/node-mitm) to intercept outgoing HTTP requests. YesNo provides a simple API to access, manipulate and record requests, using mocks or live services, so that you can easily define what requests should and should not be made by your app.

## Background

~~Please see the [introductory blog post](link) for the background on this library and the testing philosophy supporting it.~~ [_forthcoming_]

## Installation

```
npm i --save-dev yesno-http
```

## Usage

YesNo can be run in two modes, `spy` or `mock`. When you `spy` on requests YesNo will proxy intercepted requests to their original destination. When you `mock` requests YesNo will respond to requests with your defined mocks. 

If, for example, your test setup differenties between integration and unit tests you may expect to use `spy` mode for integration tests and `mock` mode for unit tests.

### Spying on Requests

When you call `yesno.spy()` YesNo will intercept requests, storing a serialized request which you can retrieve at any time.

```javascript
const { yesno } = require('yesno-http');
const { expect } = require('chai');
const fbApi = require('./fb-api');

describe('api', () => {
  it('should get users', async () => {
    yesno.spy();
    const users = await fbApi.getUsers();
    const intercepted = yesno.intercepted();

    expect(intercepted).have.lengthOf(1);
    expect(intercepted[0]).have.nested.property('url', 'https://api.facebook.com/users');
    expect(users).to.eql(intercepted[0].response.body.users);
  });
});
```

Here we assert that _only 1_ HTTP request was generated by `fbApi.getUsers()` , that the request was for the _correct URL_ and that the return value is equal to the `users` property of the JSON response body. YesNo will automatically parse the body of JSON requests/responses into an object - otherwise the body will be a string. See [ISerializedHttp](#ISerializedHttp) below to learn more about the format of serialized requests.

While we use the [Chai](link) assertion library in these examples, YesNo is not tied to any assertion library.

_Note:_ By [default](link) YesNo only intercepts requests for ports 80 (HTTP) & 443 (HTTPS).

### Recording Requests

Sometimes we

```javascript
const { yesno } = require('yesno-http');
const { expect } = require('chai');
const fbApi = require('./fb-api');

describe('api', () => {
  const mocksDir = `${__dirname}/mocks`;
  it('should get users', async () => {
    yesno.spy();
    await fbApi.getUsers();

    yesno.save('api-get-users', mocksDir);
  });
});
```

### Mocking requests

When you `mock` requests you must provide YesNo with mocks for all expected requests. YesNo responds to the Nth intercepted request with the Nth mock. If the URL of the intercepted request does not match the mock the client request will fail.

```javascript
const { yesno } = require('yesno-http');
const { expect } = require('chai');
const fbApi = require('./fb-api');

describe('api', () => {
  const mocksDir =  `${__dirname}/mocks`
  it('should get users', async () => {
    const mocks = await yesno.load('api-get-users', mocksDir)
    expect(mocks).to.have.lengthOf(1);
    yesno.mock(mocks);

    const users = await fbApi.getUsers();
  
    expect(users).to.eql(mocks[0].response.body.users);

    await fbApi.getUsers(); // Error! We only have mocks defined for 1 request, YesNo won't find a match here.
  });
});
```
The `mock` method simply accepts an array of `ISerializedHttpMock` objects, so we can choose to define our mocks inline as well.

```javascript
const { yesno } = require('yesno-http');
const { expect } = require('chai');
const fbApi = require('./fb-api');

describe('api', () => {
  it('should get users', async () => {
    yesno.mock([{
      request: {
        method: 'POST',
        path: '/users',
        host: 'facebook.com',
        protocol: 'https'
      },
      response: {
        body: {
          users: [{ username: 'foobar' }]
        },
        statusCode: 200
      }
    }]);

    const users = await fbApi.getUsers();

    expect(users).to.eql(yesno.mocks()[0].response.body.users);
  });
});
```

_Note:_ `ISerializedHttpMock` has the same shape as `ISerializedHttp`, but marks several properties as optional for convenience.

### Restoring HTTP behavior

When we no longer need YesNo to intercept requests we can call `yesno.restore()`. This will disable Mitm and any other stubs we've implemented. It's advisable to run this after every test keep state clean:

```javascript
describe('api', () => {
  beforeEach(() => yesno.spy()); // Spy on each test
  afterEach(() => yesno.restore()); // Cleanup!

  describe('lots of tests with lots of requests', () => { ... });
});
```

Calling `restore()` will clear references to any mocks we've defined and any requests we've intercepted.

### Redacting sensitive information

Sometimes our requests include sensitive information such as API keys or user passwords. YesNo provides a [`redact`](link) method to censor to censor the values of any nested property in the intercepted requests.

```javascript
yesno.spy();
apiKey = await fbApi.authenticate();
await fbApi.getUsers(apiKey);

yesno.matching(/facebook.com\/auth/).redact('response.body.token');
yesno.matching(/facebook.com\/users/).redact('request.headers.authorization');

await yesno.save('api-get-users', mocksDir);
```

## API

YesNo is written in [TypeScript](link) and uses its type syntax where possible in the API definition below.

##### [`YesNo`](#YesNo)
- [`yesno.spy(options?: IInterceptOptions): void`](link);
- [`yesno.mock(mocks?: HttpMock[], options?: IInterceptOptions): void`](link);
- [`yesno.restore(): void`](link);
- [`yesno.save(name: string, dir: string): Promise<void>`](link) (+1 overload)
- [`yesno.load(name: string, dir: string): Promise<ISerializedHttp[]>`](link) (+1 overload);
- [`yesno.filter(query: HttpFilter): FilteredHttpCollection`](link);

##### [`FilteredHttpCollection`](#FilteredHttpCollection)
- [`collection.mocks(): ISerializedHttp[]`](link);
- [`collection.intercepted(): ISerializedHttp[]`](link);
- [`collection.redact(): void`](link);
- [`collection.comparator(): void`](link);

##### [`ISerializedHttp`](link)
##### [`YesNoError`](link)

### `YesNo`

The `yesno` instance additionally implements all the methods `FilteredHttpCollection` interface (essentially running those methods with no filtering query).

##### `yesno.spy(options?: IInterceptOptions): void`


Enables intercept of requests if not already enabled and configures YesNo to `spy` mode.

##### `IInterceptOptions`

`options.ports: number[]`: Non-standard ports for which to intercept requests. Use this if you need to make a request to eg `localhost:3001`. YesNo will always intercept requests with ports `80` or `443`.

##### `yesno.mock(mocks: ISerializedHttp[] | ISerializedHttpMock[], options?: IInterceptOptions): void`

Enables intercept of requests if not already enabled and configures YesNo to `mock` mode, using the provided `mocks` to respond to requests.

When YesNo cannot provide a mock for an intercept it emits an `error` event on the corresponding [`ClientRequest`](link) instance. Most libraries will handle this by throwing an error.

See also [`IInterceptOptions`](#IInterceptOptions).

##### `yesno.restore(): void`

Restore normal HTTP functionality by disabling Mitm & restoring any defined stubs. Clears references to any stateful properties such as the defined mocks or intercepted requests.

If you're using YesNo in a test suite it's advisable to run this method after every test case.

##### `yesno.save(name: string, dir: string): Promise<void>`
##### `yesno.save(options: IFileOptions & ISaveOptions): Promise<void>`

Save serialized HTTP requests to disk. Will save currently intercepted requests unless records are provided to method. 

This method will throw an error if there are any in flight requests.

##### `yesno.load(name: string, dir: string): Promise<ISerializedHttp[]>`
##### `yesno.load(options: IFileOptions): Promise<ISerializedHttp[]>`

Load mocks from disk. Mocks will be returned. To use mocks you must pass them to `yesno.mock()`.

##### `yesno.filter(matcher: HttpFilter): FilteredHttpCollection`

Apply a filter to subsequently access or manipulate matching mocks or intercepted requests.

We define an `HttpFilter` as: `type HttpFilter = string | RegExp | IHttpMatch | (serialized: ISerializedHttp, index: number) => boolean`;

The `matcher` is applied to each serialized request to filter results. If the matcher is...

- A string: Perform an _exact_ match on URL (port optional)
- A regular expression: Test against URL (port optional)
- An object (`IHttpMatch`): Perform a deep partial comparison against the serialized request
- A function: A callback that receives the `ISerializedHttp` object and returns a `boolean` value of `true` to indicate match.

Examples:

```
yesno.filter('https://api.example.com/users'); // Exact match on url
yesno.filter(/example/); // Any request to Example website
yesno.filter({ // Any POST requests to Example with status code of 500
  request: { host: 'example.com', method: 'POST' },
  response: { statusCode: 500 }
});
yesno.filter((serialized, i) => {
  if (i === 0) { // First request
    return true;
  }

  const { request } = serialized;
  if (request.body.firstName === request.body.lastName) { // Custom logic
    return true;
  }

  return false;
});
```

### `FilteredHttpCollection`

##### `collection.mocks(): ISerializedHttp[]`

Return the mocks defined within the collection.

##### `collection.intercepted(): ISerializedHttp[]`

Return the intercepted requests defined within the collection.

##### `collection.redact(property: string | string[], symbol?: string): void`
##### `collection.redact(property: string | string[], replace?: (value: any, property: string) => any): void`

Redact properties on intercepted requests within the collection.

##### `collection.comparator((intercepted: ISerializedRequest, mock: ISerializedRequest) => boolean): void`

Provide a custom comparator to use with mocks within the collection. The comparator is used to determine whether an intercepted request matches a mock. YesNo ships with the comparators `comparators.url`, `comparators.body`, `comparators.headers`. By default YesNo will use `comparators.url`.

You can compose comparators to mix and match behavior:

```javascript
const { comparators } = require('yesno-http');
const { flow } = require('lodash'); // Composition helper

const compareAuthHeader = (intercepted, mock) => intercepted.headers.authorization === mock.headers.authorization;
yesno.filter(/auth/).comparator(flow(comparators.url, compareAuthHeader));
```

#### ISerializedHttp

```typescript
interface ISerializedHttp {
  readonly __id: string;
  readonly __version: string;
  readonly __timestamp: number;
  readonly __duration: number;
  readonly url: string;
  readonly request: SerializedRequest;
  readonly response: SerializedResponse;
}

export interface SerializedResponse {
  readonly body: string | object;
  readonly headers: IncomingHttpHeaders;
  readonly statusCode: number;
}

export interface SerializedRequest {
  readonly body?: string | object;
  readonly headers: OutgoingHttpHeaders;
  readonly host: string;
  readonly path: string;
  readonly method: string;
  readonly port: number;
  readonly query?: string;
  readonly protocol: 'http' | 'https';
}
```

### CLI

TODO

### Roadmap

YesNo is still a work in progress. The below features are planned or in consideration.

- Support non-deterministic order of HTTP requests.
- Detect HTTP requests by some heuristic other than port so user does not need to configure YesNo for non-standard ports.
- Support extensions to apply YesNo's syntax to any arbitrary protocol.