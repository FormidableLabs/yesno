<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>yesno-http</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">yesno-http</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> yesno-http</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<p><a href="https://travis-ci.com/FormidableLabs/yesno"><img src="https://travis-ci.com/FormidableLabs/yesno.svg?branch=master" alt="Build Status"></a></p>
				<h1 id="yesno">YesNo</h1>
				<p>YesNo is an HTTP testing library for NodeJS that uses <a href="https://github.com/moll/node-mitm">Mitm</a> to intercept outgoing HTTP requests. YesNo provides a simple API to access, manipulate and record requests, using mocks or live services, so that you can easily define what requests should and should not be made by your app.</p>
				<p><em>Note:</em> YesNo is still in beta! We&#39;re actively working toward our <a href="https://github.com/FormidableLabs/yesno/projects/1">first major release</a>, meaning the API is subject to change. Any and all feedback is appreciated.</p>
				<ul>
					<li><a href="#Why">Why?</a></li>
					<li><a href="#installation">Installation</a></li>
					<li><a href="#Usage">Usage</a><ul>
							<li><a href="#intercepting-live-requests">Intercepting live requests</a></li>
							<li><a href="#mocking-responses">Mocking responses</a></li>
							<li><a href="#recording-requests">Recording requests</a></li>
							<li><a href="#filtering-results">Filtering results</a></li>
							<li><a href="#restoring-http-behavior">Restoring HTTP behavior</a></li>
						</ul>
					</li>
					<li><a href="#Examples">Examples</a></li>
					<li><a href="#API">API</a></li>
				</ul>
				<h2 id="why-">Why?</h2>
				<p>NodeJS applications often need to generate HTTP requests, whether that is to orchestrate across internal microservices, integrate with third party APIs or whatever. Because the correct behavior of the app is usually dependent on <em>sending the correct request</em> and <em>receiving the correct response</em>, it&#39;s important that our tests properly validate our HTTP requests. We can accomplish this through a mix of <em>spying</em> and <em>mocking</em>.</p>
				<p>Whereas a naive approach would be to mock the method calls to our request library or configure our application to make requests to a test server, YesNo uses <a href="https://github.com/moll/node-mitm">Mitm</a> to intercept HTTP requests at the lowest level possible in process. <strong>This allows us to access the request that is <em>actually</em> generated by the application and return an <em>actual</em> response, meaning we can test the actual HTTP behavior of our application, not the behavior of our mocks.</strong></p>
				<p>YesNo&#39;s sole purpose is to provide an easy interface to intercepting requests and defining mocks. You are free to use your existing assertion library to validate requests.</p>
				<h2 id="installation">Installation</h2>
				<pre><code>npm i --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> yesno-http</code></pre><h2 id="usage">Usage</h2>
				<p><em>To see our preferred usage, skip to <a href="#recording-requests">recording</a>!</em></p>
				<h3 id="intercepting-live-requests">Intercepting live requests</h3>
				<p>To begin intercepting requests all we need to do is to call <code>yesno.spy()</code>. Afterwards we can access any <em>finished</em> requests we&#39;ve intercepted by calling <code>yesno.intercepted()</code>. The requests still sent unmodified to its destination, and the client still receives the unmodified response - we just maintain a serialized reference.</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> { yesno } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'yesno-http'</span>);
<span class="hljs-keyword">const</span> { expect } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'chai'</span>);
<span class="hljs-keyword">const</span> myApi = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../src/my-api'</span>);

describe(<span class="hljs-string">'my-api'</span>, () =&gt; {
 it(<span class="hljs-string">'should get users'</span>, <span class="hljs-keyword">async</span> () =&gt; {
   yesno.spy(); <span class="hljs-comment">// Intercept requests</span>
   <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> myApi.getUsers();
   <span class="hljs-keyword">const</span> intercepted = yesno.intercepted(); <span class="hljs-comment">// Get the intercepted requests</span>

   <span class="hljs-comment">// Intercepted requests have a standardized format</span>
   expect(intercepted).have.lengthOf(<span class="hljs-number">1</span>);
   expect(intercepted[<span class="hljs-number">0</span>]).have.nested.property(<span class="hljs-string">'url'</span>, <span class="hljs-string">'https://api.example.com/users'</span>);
   expect(users).to.eql(intercepted[<span class="hljs-number">0</span>].response.body.users); <span class="hljs-comment">// JSON bodies are parsed to objects</span>
 })
});</code></pre>
				<p>Here we assert that <em>only 1</em> HTTP request was generated by <code>myApi.getUsers()</code> , that the request was for the <em>correct URL</em> and that the return value is equal to the <code>users</code> property of the JSON response body. YesNo will automatically parse the body of JSON requests/responses into an object - otherwise the body will be a string (see <a href="#ISerializedHttp">ISerializedHttp</a> for the serialized request format).</p>
				<h3 id="mocking-responses">Mocking responses</h3>
				<p>A lot of the time when unit testings we don&#39;t want our app to hit any external services, but we still want to validate its HTTP behavior. In this case we can call <code>yesno.mock()</code>, which will intercept generated HTTP requests and respond with a provided mock response.</p>
				<pre><code class="language-javascript">yesno.mock([{
 <span class="hljs-attr">request</span>: {
   <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>,
   <span class="hljs-attr">path</span>: <span class="hljs-string">'/users'</span>,
   <span class="hljs-attr">host</span>: <span class="hljs-string">'example.com'</span>,
   <span class="hljs-attr">protocol</span>: <span class="hljs-string">'https'</span>
 },
 <span class="hljs-attr">response</span>: {
   <span class="hljs-attr">headers</span>: {
     <span class="hljs-string">'x-test-header'</span>: <span class="hljs-string">'fizbaz'</span>
   },
   <span class="hljs-attr">body</span>: {
     <span class="hljs-attr">users</span>: [{ <span class="hljs-attr">username</span>: <span class="hljs-string">'foobar'</span> }]
   },
   <span class="hljs-attr">statusCode</span>: <span class="hljs-number">200</span>
 }
}]);

<span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> myApi.getUsers();

expect(users).to.eql(yesno.mocks()[<span class="hljs-number">0</span>].response.body.users);</code></pre>
				<p>YesNo first checks to make sure the request generated by <code>myApi.getUser()</code> has the same URL as our mock, then responds with the body, status code and headers in our response.</p>
				<p>Mocks also allow us to easily test the behavior of our application when it receives &quot;unexpected&quot; responses, such as non-200 HTTP status codes or error response bodies.</p>
				<h3 id="recording-requests">Recording Requests</h3>
				<p>While mocking is useful mocks themselves are hard to maintain. When APIs changes (sometimes unexpectedly!) our mocks become stale, meaning we&#39;re testing for the wrong behavior. To solve this problem YesNo allows you to <em>record</em> requests, saving the requests we&#39;ve intercepted to a local file.</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> recording = <span class="hljs-keyword">await</span> yesno.record({ <span class="hljs-attr">filename</span>: <span class="hljs-string">'./get-users-yesno.json'</span> });
<span class="hljs-keyword">await</span> myApi.getUsers();
  expect(yesno.matching(<span class="hljs-regexp">/users/</span>).response()).to.have.property(<span class="hljs-string">'statusCode'</span>, <span class="hljs-number">200</span>);

recording.complete();</code></pre>
				<p>This workflow has the advantage of ensuring that our mocks closely represent the <em>real</em> HTTP request/responses our application deals with and making it easy to refresh these mocks when an API has been updated.</p>
				<p>To make this workflow even easier, YesNo includes a <code>test</code> method which accepts a jest or mocha style test statement and surrounds it with our record statements. Using the above as an example, we could rewrite it as:</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> itRecorded = yesno.test({ it, <span class="hljs-attr">dir</span>: <span class="hljs-string">`<span class="hljs-subst">${__dirname}</span>/mocks`</span> })

<span class="hljs-comment">// Mocks for this test will be saved to or loaded from</span>
<span class="hljs-comment">// "./mocks/get-users-yesno.json"</span>
itRecorded(<span class="hljs-string">'Get Users'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> myApi.getUsers();
  expect(yesno.matching(<span class="hljs-regexp">/users/</span>).response()).to.have.property(<span class="hljs-string">'statusCode'</span>, <span class="hljs-number">200</span>);
})</code></pre>
				<p>Now we skip the recording boilerplate and just write our test!</p>
				<p>In case you need to load and generate fixtures manually, YesNo also exposes the <code>save</code> and <code>load</code> methods that <code>record</code> uses internally.</p>
				<h3 id="filtering-results">Filtering results</h3>
				<p>Once requests have finished we still need to assert that the requests were correct. We&#39;ve already seen <code>yesno.intercepted()</code>, which returns <em>all</em> the intercepted requests, but this is just shorthand for <code>yesno.matching().intercepted()</code>, which we can use to selectively access requests.</p>
				<p>Consider the following, where we use <code>yesno.matching()</code> to access only the intercepted user request, then assert a password was hashed.</p>
				<pre><code class="language-javascript">yesno.spy();

<span class="hljs-keyword">await</span> myApi.complicatedAuthFlow(token); <span class="hljs-comment">// Lots of HTTP requests!</span>
<span class="hljs-keyword">await</span> myApi.updateUser(userId, rawPassword);

expect(
 <span class="hljs-comment">// Match only requests with this url</span>
 yesno.matching(<span class="hljs-string">`https://example.com/users/<span class="hljs-subst">${userId}</span>`</span>).intercepted()[<span class="hljs-number">0</span>]
).to.have.nested.property(<span class="hljs-string">"request.body.password"</span>, hash(rawPassword));</code></pre>
				<p>We can even use this syntax to selectively redact values from the serialized requests, so that we don&#39;t persist sensitive data to our mocks. This is a common problem when auth tokens are being sent back and forth between the APIs.</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">await</span> myApi.complicatedAuthFlow(token); <span class="hljs-comment">// Lots of HTTP requests!</span>
<span class="hljs-keyword">await</span> myApi.updateUser(userId, rawPassword);

yesno.matching(<span class="hljs-regexp">/auth/</span>).redact([<span class="hljs-string">'request.headers.authorization'</span>, <span class="hljs-string">'response.body.token'</span>]);


expect(yesno.matching(<span class="hljs-regexp">/auth/</span>).intercepted()).to.have.nested.property(
 <span class="hljs-string">'request.headers.authorization'</span>, <span class="hljs-string">'*****'</span>);

<span class="hljs-keyword">await</span> yesno.save(testName, dir); <span class="hljs-comment">// Recorded mocks are sanitized</span></code></pre>
				<p>The matching method can filter on any of the properties in the serialized object. See the API documentation for more examples.</p>
				<h3 id="restoring-http-behavior">Restoring HTTP behavior</h3>
				<p>When we no longer need YesNo to intercept requests we can call <code>yesno.restore()</code>. This will completely restore HTTP behavior &amp; clear our mocks. It&#39;s advisable to run this after every test.</p>
				<pre><code class="language-javascript">describe(<span class="hljs-string">'api'</span>, () =&gt; {
 beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> yesno.spy()); <span class="hljs-comment">// Spy on each test</span>
 afterEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> yesno.restore()); <span class="hljs-comment">// Cleanup!</span>

 describe(<span class="hljs-string">'lots of tests with lots of requests'</span>, () =&gt; { ... });
});</code></pre>
				<p>If you&#39;re using <code>yesno.test()</code> it&#39;ll call restore for you whenever it runs.</p>
				<h2 id="examples">Examples</h2>
				<p>Visit the <a href="https://github.com/FormidableLabs/yesno/tree/master/examples">examples</a> directory to see sample tests written with YesNo.</p>
				<p>You can run the tests yourselves after cloning the repo.</p>
				<pre><code class="language-sh">npm install
npm run example-server <span class="hljs-comment"># Start test server</span></code></pre>
				<p>Then in a separate window</p>
				<pre><code class="language-sh">npm run example-tests</code></pre>
				<h2 id="api">API</h2>
				<p>YesNo is written in <a href="typescriptlang.org">TypeScript</a> and uses its type syntax where possible.</p>
				<h5 id="yesno"><a href="#YesNo"><code>YesNo</code></a></h5>
				<ul>
					<li><a href="#yesnospyoptions-iinterceptoptions-void"><code>yesno.spy(options?: IInterceptOptions): void</code></a>;</li>
					<li><a href="#yesnomockmocks-iserializedhttp--iserializedhttpmock-options-iinterceptoptions-void"><code>yesno.mock(mocks?: HttpMock[], options?: IInterceptOptions): void</code></a>;</li>
					<li><a href="#yesnorecordingoptions-iinterceptoptions--ifileoptions-promiserecording"><code>yesno.recording(options?: IInterceptOptions &amp; IFileOptions): Promise&lt;Recording&gt;</code></a>;</li>
					<li><a href="#yesnotestoptions-irecordabletest-name-string-test---promiseany--void"><code>yesno.test(options: IRecordableTest): (name: string, test: () =&gt; Promise&lt;Any&gt;) =&gt; void</code></a>;</li>
					<li><a href="#yesnorestore-void"><code>yesno.restore(): void</code></a>;</li>
					<li><a href="#yesnosaveoptions-ifileoptions--isaveoptions-promisevoid"><code>yesno.save(options: IFileOptions): Promise&lt;void&gt;</code></a></li>
					<li><a href="#yesnoloadoptions-ifileoptions-promiseiserializedhttp"><code>yesno.load(options: IFileOptions &amp; ISaveOptions): Promise&lt;ISerializedHttp[]&gt;</code></a>;</li>
					<li><a href="#yesnomatchingfilter-httpfilter-filteredhttpcollection"><code>yesno.matching(query: HttpFilter): FilteredHttpCollection</code></a>;</li>
				</ul>
				<h5 id="filteredhttpcollection"><a href="#filteredhttpcollection-1"><code>FilteredHttpCollection</code></a></h5>
				<ul>
					<li><a href="#collectionmocks-iserializedhttp"><code>collection.mocks(): ISerializedHttp[]</code></a>;</li>
					<li><a href="#collectionintercepted-iserializedhttp"><code>collection.intercepted(): ISerializedHttp[]</code></a>;</li>
					<li><a href="#collectionredactproperty-string--string-redactor-redactor-----void"><code>collection.redact(property: string | string[], redactor: Redactor = () =&gt; &quot;*****&quot;): void</code></a>;</li>
					<li><a href="#collectionrequest-iserializedhttp"><code>collection.request(): ISerializedHttp</code></a>;</li>
					<li><a href="#collectionresponse-iserializedhttp"><code>collection.response(): ISerializedHttp</code></a>;</li>
				</ul>
				<h5 id="recording"><a href="#Recording"><code>Recording</code></a></h5>
				<ul>
					<li><a href="#recordingcomplete---promisevoid"><code>recording.complete(): Promise&lt;void&gt;</code></a></li>
				</ul>
				<h5 id="iserializedhttp"><a href="#link"><code>ISerializedHttp</code></a></h5>
				<h3 id="yesno"><code>YesNo</code></h3>
				<p>The <code>yesno</code> instance implements all the methods of the <code>FilteredHttpCollection</code> interface.</p>
				<h5 id="yesno-spy-options-iinterceptoptions-void"><code>yesno.spy(options?: IInterceptOptions): void</code></h5>
				<p>Enables intercept of requests if not already enabled.</p>
				<h5 id="iinterceptoptions"><code>IInterceptOptions</code></h5>
				<p><code>options.ignorePorts: number[]</code>: <em>Important.</em> Since YesNo uses Mitm internally, by default it will intercept any sockets, HTTP or otherwise. If you need to ignore a port (eg for a database connection), provide that port number here. Normally you will run YesNo after long running connections have been established, so this won&#39;t be a problem.</p>
				<h5 id="yesno-mock-mocks-iserializedhttp-iserializedhttpmock-options-iinterceptoptions-void"><code>yesno.mock(mocks: ISerializedHttp[] | ISerializedHttpMock[], options?: IInterceptOptions): void</code></h5>
				<p>Enables intercept of requests if not already enabled and configures YesNo to respond to all forthcoming intercepted requests with the provided <code>mocks</code>.</p>
				<p>YesNo responds to the Nth intercepted request with the Nth mock. If the HTTP method &amp; URL of the intercepted request does not match the corresponding mock then the client request will fail.</p>
				<p>When YesNo cannot provide a mock for an intercept it emits an <code>error</code> event on the corresponding <a href="https://nodejs.org/api/http.html#http_class_http_clientrequest"><code>ClientRequest</code></a> instance. Most libraries will handle this by throwing an error.</p>
				<p>See also <a href="#IInterceptOptions"><code>IInterceptOptions</code></a>.</p>
				<h5 id="yesno-recording-options-iinterceptoptions-ifileoptions-promiserecording"><code>yesno.recording(options?: IInterceptOptions &amp; IFileOptions): Promise&lt;Recording&gt;</code></h5>
				<p>Begin a new recording. Recording allow you to alternatively spy, record or mock behavior according to the value of the environment variable <code>YESNO_RECORDING_MODE</code>. The values and the accompanying behaviors of theses modes are described below.</p>
				<table>
					<thead>
						<tr>
							<th>Mode</th>
							<th>Value</th>
							<th>Description</th>
						</tr>
					</thead>
					<tbody><tr>
							<td>Spy</td>
							<td>&quot;spy&quot;</td>
							<td>Intercept requests &amp; proxy to destination. Don&#39;t save. Equivalent to <code>yesno.spy()</code></td>
						</tr>
						<tr>
							<td>Record</td>
							<td>&quot;record&quot;</td>
							<td>Intercept requests &amp; proxy to destination. Save to disk on completion. Equivalent to <code>yesno.spy()</code> &amp; <code>yesno.save()</code></td>
						</tr>
						<tr>
							<td>Mock</td>
							<td>&quot;mock&quot; (default)</td>
							<td>Load mocks from disks. Intercept requests &amp; respond with mocks. Don&#39;t save. Equivalent to <code>yesno.mock(await yesno.load())</code>.</td>
						</tr>
				</tbody></table>
				<p><strong>Example</strong></p>
				<pre><code class="language-javascript"><span class="hljs-comment">// Begin a recording. Load mocks if in "mock" mode, otherwise spy.</span>
<span class="hljs-keyword">const</span> recording = <span class="hljs-keyword">await</span> yesno.recording({
  <span class="hljs-attr">filename</span>: <span class="hljs-string">'./get-users.json'</span>
})

<span class="hljs-comment">// Make our HTTP requests</span>
<span class="hljs-keyword">await</span> myApi.getUsers()

<span class="hljs-comment">// Run assertions</span>
expect(yesno.matching(<span class="hljs-regexp">/users/</span>).response()).to.have.property(<span class="hljs-string">'statusCode'</span>, <span class="hljs-number">200</span>)

<span class="hljs-comment">// Persist intercepted requests if in "record" mode, otherwise no-op</span>
<span class="hljs-keyword">await</span> recording.complete()</code></pre>
				<h5 id="yesno-test-options-irecordabletest-name-string-test-promiseany-void"><code>yesno.test(options: IRecordableTest): (name: string, test: () =&gt; Promise&lt;any&gt;) =&gt; void</code></h5>
				<p>A utility method for creating test definitions instrumented with <code>yesno.recording()</code>. It accepts any testing method <code>it</code> or <code>test</code> which accepts a <code>name</code> and <code>test</code> function as its arguments, along with a directory and optional prefix to use for recording fixtures.</p>
				<h5 id="irecordabletest"><code>IRecordableTest</code></h5>
				<p><code>options.test: (name: string, test: () =&gt; Promise&lt;any&gt;) =&gt; any</code>: A test function, such as <code>jest.test</code> or <code>mocha.it</code> which accepts a name and test definition. The test may either be synchronous or return a promise.</p>
				<p><code>options.it: (name: string, test: () =&gt; Promise&lt;any&gt;) =&gt; any</code>: Alias for <code>options.test</code></p>
				<p><code>options.dir: string</code>: Directory to use for recording</p>
				<p><code>options.prefix?: string</code>: <em>Optional</em>. Prefix to use for all fixtures. Useful to prevent conflicts with similarly named tests in other files.</p>
				<p><strong>Example</strong></p>
				<p>Given the below test written with <code>yesno.recording</code>....</p>
				<pre><code class="language-javascript">it(<span class="hljs-string">'should get users'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> recording = <span class="hljs-keyword">await</span> yesno.recording({ <span class="hljs-attr">filename</span>: <span class="hljs-string">`<span class="hljs-subst">${__dirname}</span>/mocks/should-get-users-yesno.json`</span> });
  <span class="hljs-keyword">await</span> myApi.getUsers();
  <span class="hljs-keyword">await</span> recording.save()
})</code></pre>
				<p>...we may write it more concisely with <code>yesno.test</code> as</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> itRecorded = yesno.test({ it, <span class="hljs-attr">dir</span>: <span class="hljs-string">`<span class="hljs-subst">${__dirname}</span>/mocks`</span> });

itRecorded(<span class="hljs-string">'should get users'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">await</span> myApi.getUsers();
});</code></pre>
				<p>Which removes much of the boilerplate from our test.</p>
				<h5 id="yesno-restore-void"><code>yesno.restore(): void</code></h5>
				<p>Restore normal HTTP functionality by disabling Mitm &amp; restoring any defined stubs. Clears references to any stateful properties such as the defined mocks or intercepted requests.</p>
				<p>If you&#39;re using YesNo in a test suite it&#39;s advisable to run this method after every test case.</p>
				<h5 id="yesno-save-options-ifileoptions-isaveoptions-promisevoid"><code>yesno.save(options: IFileOptions &amp; ISaveOptions): Promise&lt;void&gt;</code></h5>
				<p>Save serialized HTTP requests to disk. Unless records are provided directly, yesno will save the currently intercepted requests.</p>
				<p>You may provide a <code>filename</code> in the options object <em>or</em> use the name &amp; directory shorthand to generate a filename from a human readable string.</p>
				<pre><code class="language-javascript"><span class="hljs-keyword">const</span> testName = <span class="hljs-string">'should hit the api'</span>
yesno.save(testName, mocksDir) <span class="hljs-comment">// =&gt; "./test/mocks/should-hit-the-api-yesno.json"</span></code></pre>
				<p>Unless providing records, this method will throw an error if there are any in flight requests to prevent users from accidentally saving before all requests have completed.</p>
				<h5 id="ifileoptions"><code>IFileOptions</code></h5>
				<p><code>options.filename: string</code>: Full filename (JSON)</p>
				<h5 id="isaveoptions"><code>ISaveOptions</code></h5>
				<p><code>options.records?: ISerializedHttp[]</code>: Records to save. Defaults to already intercepted requests.</p>
				<h5 id="yesno-load-options-ifileoptions-promiseiserializedhttp-"><code>yesno.load(options: IFileOptions): Promise&lt;ISerializedHttp[]&gt;</code></h5>
				<p>Load serialized HTTP requests from a local JSON file.</p>
				<p>See <a href="#ifileoptions"><code>IFileOptions</code></a>.</p>
				<h5 id="yesno-matching-filter-httpfilter-filteredhttpcollection"><code>yesno.matching(filter?: HttpFilter): FilteredHttpCollection</code></h5>
				<p>Apply a filter to subsequently access or manipulate matching mocks or intercepted requests.</p>
				<p>We define an <code>HttpFilter</code> as: <code>type HttpFilter = string | RegExp | ISerializedHttpPartialDeepMatch | (serialized: ISerializedHttp) =&gt; boolean</code>;</p>
				<p>The <code>filter</code> is applied to each serialized request to filter results. If the filter is...</p>
				<ul>
					<li>A string: Perform an <em>exact</em> match on URL (port optional)</li>
					<li>A regular expression: Test against URL (port optional)</li>
					<li>An object (<code>ISerializedHttpPartialDeepMatch</code>): Perform a deep partial comparison against the serialized request</li>
					<li>A function: A callback that receives the <code>ISerializedHttp</code> object and returns a <code>boolean</code> value of <code>true</code> to indicate match.</li>
					<li><code>undefined</code>: The entire collection is returned.</li>
				</ul>
				<p>Examples:</p>
				<pre><code class="language-javascript">yesno.matching(<span class="hljs-string">'https://api.example.com/users'</span>); <span class="hljs-comment">// Exact match on url</span>
yesno.matching(<span class="hljs-regexp">/example/</span>); <span class="hljs-comment">// Any request to Example website</span>
yesno.matching({ <span class="hljs-comment">// Any POST requests to Example with status code of 500</span>
 request: { <span class="hljs-attr">host</span>: <span class="hljs-string">'example.com'</span>, <span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span> },
 <span class="hljs-attr">response</span>: { <span class="hljs-attr">statusCode</span>: <span class="hljs-number">500</span> }
});
yesno.matching(<span class="hljs-function">(<span class="hljs-params">serialized, i</span>) =&gt;</span> {
 <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>) { <span class="hljs-comment">// First request</span>
   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
 }

 <span class="hljs-keyword">const</span> { request } = serialized;
 <span class="hljs-keyword">if</span> (request.body.firstName === request.body.lastName) { <span class="hljs-comment">// Custom logic</span>
   <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
 }

 <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
});
yesno.matching().response(); <span class="hljs-comment">// short-cut to get the response from the one intercepted request</span></code></pre>
				<h3 id="filteredhttpcollection"><code>FilteredHttpCollection</code></h3>
				<h5 id="collection-mocks-iserializedhttp-"><code>collection.mocks(): ISerializedHttp[]</code></h5>
				<p>Return the mocks defined within the collection.</p>
				<h5 id="collection-intercepted-iserializedhttp-"><code>collection.intercepted(): ISerializedHttp[]</code></h5>
				<p>Return the intercepted requests defined within the collection.</p>
				<h5 id="collection-redact-property-string-string-redactor-redactor-void"><code>collection.redact(property: string | string[], redactor: Redactor = () =&gt; &quot;*****&quot;): void</code></h5>
				<p><code>property</code>: Property or array of properties on serialized requests to redact.
				<code>redactor</code>: Callback that receives value and property path on matching requests. Return value will be used as redacted value.</p>
				<p>Redact properties on intercepted requests within the collection. Nested properties may be indicated using <code>.</code>.</p>
				<p><strong>Example</strong></p>
				<pre><code class="language-javascript"><span class="hljs-keyword">await</span> myApi.getToken(apiKey)

<span class="hljs-comment">// Replace the auth values with an md5 hash</span>
yesno.matching(<span class="hljs-regexp">/login/</span>).redact(
  [<span class="hljs-string">'request.headers.authorization'</span>, <span class="hljs-string">'response.body.token'</span>],
  (value, path) =&gt; md5(value)
)
<span class="hljs-keyword">await</span> yesno.save({ <span class="hljs-attr">filename</span>: <span class="hljs-string">'redacted.json'</span> })</code></pre>
				<h5 id="collection-request-iserializedhttp"><code>collection.request(): ISerializedHttp</code></h5>
				<p>Return the request part of the <em>single</em> matching HTTP request.</p>
				<p>Throws an error if the collection does not match <em>one and only one</em> request.</p>
				<p><strong>Example</strong></p>
				<pre><code class="language-javascript"><span class="hljs-keyword">await</span> myApi.getUsers(token);

expect(yesno.matching(<span class="hljs-regexp">/users/</span>).request()).to.have.nested.property(<span class="hljs-string">'headers.authorization'</span>, token)</code></pre>
				<h5 id="collection-response-iserializedhttp"><code>collection.response(): ISerializedHttp</code></h5>
				<p>Response corollary to <code>collection.request()</code>. Return the response part of the <em>single</em> matching HTTP request.</p>
				<p>Throws an error if the collection does not match <em>one and only one</em> request.</p>
				<h4 id="recording">Recording</h4>
				<h5 id="recording-complete-promisevoid"><code>recording.complete(): Promise&lt;void&gt;</code></h5>
				<p>Save the request if we&#39;re in record mode. Otherwise no-op.</p>
				<h4 id="iserializedhttp">ISerializedHttp</h4>
				<p><code>`</code>typescript
					interface ISerializedHttp {
					readonly __id: string;
					readonly __version: string;
					readonly __timestamp: number;
					readonly __duration: number;
					readonly request: SerializedRequest;
					readonly response: SerializedResponse;
				}</p>
				<p>export interface SerializedResponse {
					readonly body: string | object;
					readonly headers: IncomingHttpHeaders;
					readonly statusCode: number;
				}</p>
				<p>export interface SerializedRequest {
					readonly body?: string | object;
					readonly headers: OutgoingHttpHeaders;
					readonly host: string;
					readonly path: string;
					readonly method: string;
					readonly port: number;
					readonly query?: string;
					readonly protocol: &#39;http&#39; | &#39;https&#39;;
				}</p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_consts_.html">"consts"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_context_.html">"context"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_errors_.html">"errors"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_file_.html">"file"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_filtering_collection_.html">"filtering/collection"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_filtering_comparator_.html">"filtering/comparator"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_filtering_matcher_.html">"filtering/matcher"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_filtering_redact_.html">"filtering/redact"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_http_serializer_.html">"http-<wbr>serializer"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_index_.html">"index"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_interceptor_.html">"interceptor"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_recording_.html">"recording"</a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_yesno_.html">"yesno"</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>